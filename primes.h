/**
 * @file
 * @brief Заголовочный файл класса простых чисел.
 */

#ifndef PRIMES_H
#define PRIMES_H

#include <cmath>

/**
 * @brief Структура, описывающая один узел односвязного списка.
 */
struct Node
{
    /**
     * @brief Базовый конструктор структуры Node. Инициализирует указатель на следующий элемент в nullptr.
     */
    Node() : next(nullptr) {}

    /**
     * @brief Конструктор с присвоением элемента.
     * @param data Хранимый данным узлом элемент
     */
    Node(int data) : data(data), next(nullptr) {}

    int data; ///< Число, хранящееся в узле списка
    Node* next; ///< Указатель на следующий элемент в односвязном списке
};

/**
 * @brief Класс для вычисления и хранения простых чисел.
 *
 * Данный класс реализован в виде односвязного списка, имеет методы для вычисления простых чисел в нужном режиме,
 *  возможности для прохода по элементам, а также возможность вычисления затрат памяти на хранение объектов.
 */
class Primes
{
private:
    Node* head = nullptr; ///< Указатель на головной элемент списка
    Node* tail = nullptr; ///< Указатель на хвостовой элемент списка

    bool isRangeSearch; ///< Режим поиска простых чисел
    int value; ///< Значение поиска. Его назначение зависит от режима поиска
private:
    /**
     * @brief Добавляет некоторое число в контейнер.
     * @param value Значение, которое будет добавлено
     */
    void append(int value);

    /**
     * @brief Очищает контейнер, удаляя все элементы.
     */
    void clear();

    /**
     * @brief Функция для проверки, является ли число простым.
     * @param x Проверяемое на простоту целое число
     * @return Логическое значение, является ли число простым
     */
    bool isPrime(int x) const;
public:
    /**
     * @brief Класс-итератор, позволяющий проходить по элементам контейнера.
     */
    class Iterator
    {
    private:
        Node* node;
    public:
        /**
         * @brief Конструктор итератора.
         * @param node Узел контейнера-списка, на который указывает итератор
         */
        Iterator(Node* node) { this->node = node; }

        /**
         * @brief Оператор инкремента для возможности изменения положения итератора.
         * @return Объект-итератор, который указывает на элемент, следующий за текущим
         */
        Iterator operator++(int) { Iterator it = *this; node = node->next; return it; }

        /**
         * @brief Оператор разыменования итератора, позволяющий получить значение объекта.
         * @return Ссылка на значение, хранящееся в узле списка, на который указывает итератор
         */
        int& operator*() const { return node->data; }

        /**
         * @brief Оператор равенства итераторов для проверки, не указывают ли два итератора на один элемент.
         * @param it Другой объект-итератор
         * @return Значение true, если итераторы равны, false в противном случае
         */
        bool operator==(const Iterator& it) const { return node == it.node; }

        /**
         * @brief Оператор "не равно", имеющий действие, противоположное bool operator==(const Iterator& it).
         * @param it Другой объект-итератор
         * @return Значение true, если итераторы не равны, false в противном случае
         */
        bool operator!=(const Iterator& it) const { return node != it.node; }
    };

    /**
     * @brief Основной конструктор класса-контейнера Primes.
     * @param isRangeSearch Параметр для определения режима поиска простых чисел (true - режим "диапазон",
     *  false - режим "определенное количество чисел")
     * @param value Значение, зависящее от режима (в режиме "диапазон" является верхней границей поиска,
     *  в режиме "количество чисел" - необходимым количеством чисел для поиска)
     */
    Primes(bool isRangeSearch = true, int value = 100);

    /**
     * @brief Конструктор копирования контейнера.
     * @param primes Другой объект текущего класса
     */
    Primes(const Primes& primes);

    /**
     * @brief Конструктор перемещения контейнера.
     * @param primes Другой объект текущего класса
     */
    Primes(Primes&& primes);

    /**
     * @brief Оператор копирования контейнера.
     * @param primes Другой объект текущего класса
     * @return Ссылка на текущий объект класса
     */
    Primes& operator=(const Primes& primes);

    /**
     * @brief Оператор перемещения контейнера.
     * @param primes Другой объект текущего класса
     * @return Ссылка на текущий объект класса
     */
    Primes& operator=(Primes&& primes);

    /**
     * @brief Функция, вычисляющая простые числа.
     * @details Данная функция вычисляет простые числа. Ее поведение зависит от значения параметра isRangeSearch.
     *  При isRangeSearch = true вычисляются простые числа до верхней границы value, в противном случае вычисляется
     *  value простых чисел.
     */
    void calculatePrimes();

    /**
     * @brief Итератор, указывающий на начало контейнера.
     * @return Объект-итератор, ссылающийся на первый элемент контейнера
     */
    Iterator begin() const;

    /**
     * @brief Итератор, указывающий на несуществующий элемент контейнера, следующий за последним.
     * @return Объект-итератор, ссылающийся на следующий за последним элемент контейнера
     */
    Iterator end() const;

    /**
     * @brief Функция, позволяющая узнать текущий размер контейнера.
     * @return Количество хранимых в контейнере простых чисел
     */
    int size() const;

    /**
     * @brief Деструктор класса Primes.
     */
    ~Primes();
};

#endif // PRIMES_H
